------------------------------------------------------------------------
-- Release notes for Agda version 2.4.4
------------------------------------------------------------------------

TODO: replace X by a suitable number.
Important changes since 2.4.2.X:

Installation and infrastructure
===============================

* For best performance, compile Agda with ghc-7.8.
  Agda is significantly slower if compiled with ghc-7.6.
  [Issue 1347]

Pragmas and options
===================

* New option --exact-split.

  The --exact-split flag causes Agda to raise an error whenever a clause in a
  definition by pattern matching cannot be made to hold definitionally (i.e. as
  a reduction rule). Specific clauses can be excluded from this check by means
  of the {-# CATCHALL #-} pragma.

  For instance, the following definition will be rejected as the second clause
  cannot be made to hold definitionally:

    min : Nat → Nat → Nat
    min zero    y       = zero
    min x       zero    = zero
    min (suc x) (suc y) = suc (min x y)

  Catchall clauses have to be marked as such, for instance:

    eq : Nat → Nat → Bool
    eq zero    zero    = true
    eq (suc m) (suc n) = eq m n
    {-# CATCHALL #-}
    eq _       _       = false

* New option: --no-exact-split.

  This option can be used to override a global --exact-split in a
  file, by adding a pragma {-# OPTIONS --no-exact-split #-}.

Language
========

Operator syntax
---------------

* The default fixity has changed.

  The default fixity, used when no fixity declaration is given, was
  previously infix 20 for operators, and infix -666 for syntax
  declarations. Now operators and notations (coming from syntax
  declarations) without an associated fixity declaration are unrelated
  to all other operators, and infix operators/notations are
  non-associative.

  As an example, the following code no longer parses:

    infix 4 _≡_

    data _≡_ {A : Set} (x : A) : A → Set where
      refl : x ≡ x

    LeftZero : {A : Set} → A → (A → A → A) → Set
    LeftZero z _∙_ = ∀ x → z ∙ x ≡ z

  Note that an operator without a fixity declaration is still related
  to itself. This has no effect for infix operators, but it means that
  a prefix (or postfix) operator can be applied directly to itself:

    postulate
      ℤ  : Set
      n  : ℤ
      -_ : ℤ → ℤ

    ok : ℤ
    ok = - - - - - - - n

* Sections.

  Operators can be sectioned by replacing arguments with underscores.
  There must not be any whitespace between these underscores and the
  adjacent nameparts. Examples:

    pred : ℕ → ℕ
    pred = _∸ 1

    T : Bool → Set
    T = if_then ⊤ else ⊥

    if : {A : Set} (b : Bool) → A → A → A
    if b = if b then_else_

  Sections are translated into lambda expressions. Examples:

    _∸ 1              ↦  λ .section₀ → .section₀ ∸ 1

    if_then ⊤ else ⊥  ↦  λ .section₀ → if .section₀ then ⊤ else ⊥

    if b then_else_   ↦  λ .section₀ .section₁ →
                             if b then .section₀ else .section₁

  Operator sections are unrelated to all other operators.

  Operator sections are not supported in patterns (with the exception
  of dot patterns), and notations coming from syntax declarations
  cannot be sectioned.

* A long-standing operator fixity bug has been fixed. As a consequence
  some programs that used to parse no longer do.

  Previously each precedence level was (incorrectly) split up into
  five separate ones, ordered as follows, with the earlier ones
  binding less tightly than the later ones:

    - Non-associative operators.

    - Left associative operators.

    - Right associative operators.

    - Prefix operators.

    - Postfix operators.

  Now this problem has been addressed. It is no longer possible to mix
  operators of a given precedence level but different associativity.
  However, prefix and right associative operators are seen as having
  the same associativity, and similarly for postfix and left
  associative operators.

  Examples
  --------

  The following code is no longer accepted:

    infixl 6 _+_
    infix  6 _∸_

    rejected : ℕ
    rejected = 1 + 0 ∸ 1

  However, the following previously rejected code is accepted:

    infixr 4 _,_
    infix  4 ,_

    ,_ : {A : Set} {B : A → Set} {x : A} → B x → Σ A B
    , y = _ , y

    accepted : Σ ℕ λ i → Σ ℕ λ j → Σ (i ≡ j) λ _ → Σ ℕ λ k → j ≡ k
    accepted = 5 , , refl , , refl

* The classification of notations with binders into the categories
  infix, prefix, postfix or closed has changed. [Issue 1450]

  The difference is that, when classifying the notation, only
  /regular/ holes are taken into account, not /binding/ ones.

  Example: The notation

    syntax m >>= (λ x → f) = x <- m , f

  was previously treated as infix, but is now treated as prefix.

* If an overloaded operator is in scope with several distinct
  fixities, then several instances of this operator will be included
  in the operator grammar, possibly leading to ambiguity. Previously
  the operator was given the default fixity [Issue 1436].

  Similarly, if two or more identical notations (coming from syntax
  declarations) for a given overloaded constructor are in scope, and
  these notations do not all have the same fixity, then several
  instances of the notation will be included in the operator grammar.

Other changes
-------------

* Building records from modules.

  The "record { <fields> }" syntax is now extended to accept module names as
  well. Fields are thus defined using the corresponding definitions from the
  given module.

  For instance assuming this record type R and module M:

  record R : Set where
    field
      x : X
      y : Y
      z : Z

  module M where
    x = {! ... !}
    y = {! ... !}

  r : R
  r = record { M; z = {! ... !} }

  Previously one had to write `record { x = M.x; y = M.y; z = {! ... !} }`.

  More precisely this construction now supports any combination of explicit
  field definitions and applied modules.

  If a field is both given explicitly and available in one of the modules,
  then the explicit one takes precedence.

  If a field is available in more than one module then this is ambiguous
  and therefore rejected. As a consequence the order of assignments does
  not matter.

  The modules can be both applied to arguments and have import directives
  such as `hiding`, `using`, and `renaming`. In particular this construct
  subsumes the record update construction.

  Here is an example of record update:

  -- Record update. Same as: record r { y = {! ... !} }
  r2 : R
  r2 = record { R r; y = {! ... !} }

  A contrived example showing the use of hiding/renaming:

  module M2 (a : A) where
    w = {! ... !}
    z = {! ... !}

  r3 : A → R
  r3 a = record { M hiding (y); M2 a renaming (w to y) }

* Unquoting function definitions.

  There is a new declaration

    unquoteDef x = e

  Here e should have type LIST AGDACLAUSE and evaluate to a closed value. Since
  unquoteDef only contains the function clauses you need a separate type
  signature. For instance, given that you have a 'derivingEq' function that
  builds decidable equality functions, you would say

    eqNat : (x y : Nat) → Dec (x ≡ y)
    unquoteDef eqNat = derivingEq (quote Nat) (quote eqNat)

  Note that, in contrast to unquoteDecl, you have to quote the name of the
  defined function to get a QNAME.

  The main advantage of unquoteDef over unquoteDecl is that unquoteDef is
  allowed in mutual blocks, allowing you to create mutually recursive
  definitions by unquoting.

* The reflection interface now exposes the name hint (as a string)
  for variables. As before, the actual binding structure is with
  de Bruijn indices. The String value is just a hint used as a prefix
  to help display the variable. The type Abs is a new bultin type used
  for the constructors `Term.lam`, `Term.pi`, `Pattern.var`
  (bultins `AGDATERMLAM`, `AGDATERMPI` and `AGDAPATVAR`).

    data Abs (A : Set) : Set where
      abs : (s : String) (x : A) → Abs A
    {-# BUILTIN ABS    Abs #-}
    {-# BUILTIN ABSABS abs #-}

  Updated constructor types:

    Term.lam    : Hiding   → Abs Term → Term
    Term.pi     : Arg Type → Abs Type → Term
    Pattern.var : String   → Pattern

* QuoteContext.

  The `quoteContext' keyword now returns a reflected representation of the current context as
  a term of type `List (Arg Type)'. For example:

    test : (n : Nat) (x y : Fin n) → quoteContext ≡
      arg₀ (el (lit 0) (def (quote Fin) (arg₀ (var 1 []) ∷ []))) ∷
      arg₀ (el (lit 0) (def (quote Fin) (arg₀ (var 0 []) ∷ []))) ∷
      arg₀ (el (lit 0) (def (quote Nat) [])) ∷ []
    test n x y = refl

  In addition, tactics now take an additional argument for the current context, i.e. instead
  of type `Term → Term', they should now have type `List (Arg Type) → Term → Term'.

* Large indices.

  Force constructor arguments no longer count towards the size of a datatype.
  For instance, the definition of equality below is accepted.

    data _≡_ {a} {A : Set a} : A → A → Set where
      refl : ∀ x → x ≡ x

  This gets rid of the asymmetry that the version of equality which indexes
  only on the second argument could be small, but not the version above which
  indexes on both arguments.

* Unicode ellipsis character is allowed for the ellipsis token ... in
  `with` expressions.

Goal and error display
======================

Type checking
=============

* Call-by-need evaluation.

  Compile-time evaluation (during type checking and from the Emacs mode) is now
  using call-by-need rather than call-by-name.

Compiler backends
=================

Tools
=====

LaTeX-backend
-------------

* The default font has been changed to XITS (which is part of TeX Live):

    http://www.ctan.org/tex-archive/fonts/xits/

  This font is more complete with respect to Unicode.
