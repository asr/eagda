checking declaration
module Agda.Primitive where
  syntax Level ...
  postulate Level : Set
  {-# COMPILE GHC Level = type () #-}
  {-# BUILTIN LEVEL Level #-}
  syntax lzero ...
  postulate lzero : Level
  syntax lsuc ...
  postulate lsuc : (ℓ : Level) → Level
  infixl 6 _⊔_
  syntax _⊔_ ...
  postulate _⊔_ : (ℓ₁ ℓ₂ : Level) → Level
  {-# BUILTIN LEVELZERO lzero #-}
  {-# BUILTIN LEVELSUC lsuc #-}
  {-# BUILTIN LEVELMAX _⊔_ #-}
checking section Agda.Primitive
adding section: Agda.Primitive 0
    actual tele:
checking declaration
syntax Level ...
postulate Level : Set
checking declaration
syntax Level ...
postulate Level : Set
checked type signature Level : Set of sort  Set₁
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
checking declaration
{-# COMPILE GHC Level = type () #-}
checking declaration
{-# COMPILE GHC Level = type () #-}
checking declaration
{-# BUILTIN LEVEL Level #-}
checking declaration
{-# BUILTIN LEVEL Level #-}
{ checkExpr
inferred def  Level
   :  Set
   -->  Level
compareTerm Set =< Set : Set₁
Solving awake constraints. 0 remaining.
}
checking declaration
syntax lzero ...
postulate lzero : Level
checking declaration
syntax lzero ...
postulate lzero : Level
{ checkExpr
inferred def  Level
   :  Set
   -->  Level
term _0 :DirEq .#Lacking_Level_Builtins#
term _0 :DirEq .#Lacking_Level_Builtins#
solving _0 := .#Lacking_Level_Builtins#
compareTerm Set =< Set : Set₁
Solving awake constraints. 0 remaining.
}
checked type signature lzero : Level of sort  Set
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
checking declaration
syntax lsuc ...
postulate lsuc : (ℓ : Level) → Level
checking declaration
syntax lsuc ...
postulate lsuc : (ℓ : Level) → Level
{ checkExpr
inferred def  Level
   :  Set
   -->  Level
term _1 :DirEq .#Lacking_Level_Builtins#
term _1 :DirEq .#Lacking_Level_Builtins#
solving _1 := .#Lacking_Level_Builtins#
compareTerm Set =< Set : Set₁
Solving awake constraints. 0 remaining.
}
{ checkExpr
inferred def  Level
   :  Set
   -->  Level
term _2 ℓ :DirEq .#Lacking_Level_Builtins#
term _2 ℓ :DirEq .#Lacking_Level_Builtins#
solving _2 := λ ℓ → .#Lacking_Level_Builtins#
compareTerm Set =< Set : Set₁
Solving awake constraints. 0 remaining.
}
checked type signature lsuc : Level → Level of sort  Set
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
checking declaration
infixl 6 _⊔_
syntax _⊔_ ...
postulate _⊔_ : (ℓ₁ ℓ₂ : Level) → Level
checking declaration
infixl 6 _⊔_
syntax _⊔_ ...
postulate _⊔_ : (ℓ₁ ℓ₂ : Level) → Level
{ checkExpr
inferred def  Level
   :  Set
   -->  Level
term _3 :DirEq .#Lacking_Level_Builtins#
term _3 :DirEq .#Lacking_Level_Builtins#
solving _3 := .#Lacking_Level_Builtins#
compareTerm Set =< Set : Set₁
Solving awake constraints. 0 remaining.
}
{ checkExpr
inferred def  Level
   :  Set
   -->  Level
term _4 ℓ₁ ℓ₂ :DirEq .#Lacking_Level_Builtins#
term _4 ℓ₁ ℓ₂ :DirEq .#Lacking_Level_Builtins#
solving _4 := λ ℓ₁ ℓ₂ → .#Lacking_Level_Builtins#
compareTerm Set =< Set : Set₁
Solving awake constraints. 0 remaining.
}
checked type signature _⊔_ : Level → Level → Level of sort  Set
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
checking declaration
{-# BUILTIN LEVELZERO lzero #-}
checking declaration
{-# BUILTIN LEVELZERO lzero #-}
{ checkExpr
inferred def  lzero
   :  Level
   -->  lzero
coerce term      v  = lzero
       from type t1 = Level
       to type   t2 = Level
compareTerm Level =< Level : Set
Solving awake constraints. 0 remaining.
}
checking declaration
{-# BUILTIN LEVELSUC lsuc #-}
checking declaration
{-# BUILTIN LEVELSUC lsuc #-}
{ checkExpr
inferred def  lsuc
   :  Level → Level
   -->  lsuc
coerce term      v  = lsuc
       from type t1 = Level → Level
       to type   t2 = Level → Level
compareTerm Level → Level =< Level → Level : Set
Solving awake constraints. 0 remaining.
}
checking declaration
{-# BUILTIN LEVELMAX _⊔_ #-}
checking declaration
{-# BUILTIN LEVELMAX _⊔_ #-}
{ checkExpr
inferred def  _⊔_
   :  Level → Level → Level
   -->  _⊔_
coerce term      v  = _⊔_
       from type t1 = Level → Level → Level
       to type   t2 = Level → Level → Level
compareTerm Level → Level → Level =< Level → Level → Level : Set
Solving awake constraints. 0 remaining.
}
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
Removed 0 unused definitions.
checking declaration
module Agda.Primitive.Cubical where
  {-# BUILTIN INTERVAL I #-}
  {-# BUILTIN IZERO i0 #-}
  {-# BUILTIN IONE i1 #-}
  infixr 20 primIMin
  syntax primIMin ...
  primitive primIMin : I → I → I
  infixr 20 primIMax
  syntax primIMax ...
  primitive primIMax : I → I → I
  infix 30 primINeg
  syntax primINeg ...
  primitive primINeg : I → I
  {-# BUILTIN ISONE IsOne #-}
  syntax itIsOne ...
  postulate itIsOne : IsOne i1
  syntax IsOne1 ...
  postulate IsOne1 : ∀ i j → IsOne i → IsOne (primIMax i j)
  syntax IsOne2 ...
  postulate IsOne2 : ∀ i j → IsOne j → IsOne (primIMax i j)
  {-# BUILTIN ITISONE itIsOne #-}
  {-# BUILTIN ISONE1 IsOne1 #-}
  {-# BUILTIN ISONE2 IsOne2 #-}
  {-# BUILTIN PARTIAL Partial #-}
  {-# BUILTIN PARTIALP PartialP #-}
  syntax isOneEmpty ...
  postulate
    isOneEmpty : ∀ {a} {A : Partial (Set a) i0} → PartialP i0 A
  {-# BUILTIN ISONEEMPTY isOneEmpty #-}
  syntax primPFrom1 ...
  primitive
    primPFrom1 :
      ∀ {a} {A : I → Set a} → A i1 → ∀ i j → Partial (A (primIMax i j)) i
  syntax primPOr ...
  primitive
    primPOr :
      ∀ {a} (i j : I) {A : Partial (Set a) (primIMax i j)} →
      PartialP i (λ z → A (IsOne1 i j z)) →
      PartialP j (λ z → A (IsOne2 i j z)) → PartialP (primIMax i j) A
  syntax primComp ...
  primitive
    primComp :
      ∀ {a} (A : (i : I) → Set (a i)) (φ : I) →
      (∀ i → Partial (A i) φ) → (a₁ : A i0) → A i1
checking section Agda.Primitive.Cubical
adding section: Agda.Primitive.Cubical 0
    actual tele:
checking declaration
{-# BUILTIN INTERVAL I #-}
checking declaration
{-# BUILTIN INTERVAL I #-}
checking declaration
{-# BUILTIN IZERO i0 #-}
checking declaration
{-# BUILTIN IZERO i0 #-}
checking declaration
{-# BUILTIN IONE i1 #-}
checking declaration
{-# BUILTIN IONE i1 #-}
checking declaration
infixr 20 primIMin
syntax primIMin ...
primitive primIMin : I → I → I
checking declaration
infixr 20 primIMin
syntax primIMin ...
primitive primIMin : I → I → I
{ checkExpr
inferred def  I
   :  Setω
   -->  I
coerce term      v  = I
       from type t1 = Setω
       to type   t2 = Set _0
term _0 :DirEq Setω
term _0 :DirEq Setω
solving _0 := Setω
compareTerm Setω =< Setω : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
inferred def  I
   :  Setω
   -->  I
coerce term      v  = I
       from type t1 = Setω
       to type   t2 = Set _1
term _1 :DirEq Setω
term _1 :DirEq Setω
solving _1 := Setω
compareTerm Setω =< Setω : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
inferred def  I
   :  Setω
   -->  I
coerce term      v  = I
       from type t1 = Setω
       to type   t2 = Set _2
term _2 :DirEq Setω
term _2 :DirEq Setω
solving _2 := Setω
compareTerm Setω =< Setω : Setω
Solving awake constraints. 0 remaining.
}
compareTerm I → I → I = I → I → I : Setω
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
checking declaration
infixr 20 primIMax
syntax primIMax ...
primitive primIMax : I → I → I
checking declaration
infixr 20 primIMax
syntax primIMax ...
primitive primIMax : I → I → I
{ checkExpr
inferred def  I
   :  Setω
   -->  I
coerce term      v  = I
       from type t1 = Setω
       to type   t2 = Set _3
term _3 :DirEq Setω
term _3 :DirEq Setω
solving _3 := Setω
compareTerm Setω =< Setω : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
inferred def  I
   :  Setω
   -->  I
coerce term      v  = I
       from type t1 = Setω
       to type   t2 = Set _4
term _4 :DirEq Setω
term _4 :DirEq Setω
solving _4 := Setω
compareTerm Setω =< Setω : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
inferred def  I
   :  Setω
   -->  I
coerce term      v  = I
       from type t1 = Setω
       to type   t2 = Set _5
term _5 :DirEq Setω
term _5 :DirEq Setω
solving _5 := Setω
compareTerm Setω =< Setω : Setω
Solving awake constraints. 0 remaining.
}
compareTerm I → I → I = I → I → I : Setω
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
checking declaration
infix 30 primINeg
syntax primINeg ...
primitive primINeg : I → I
checking declaration
infix 30 primINeg
syntax primINeg ...
primitive primINeg : I → I
{ checkExpr
inferred def  I
   :  Setω
   -->  I
coerce term      v  = I
       from type t1 = Setω
       to type   t2 = Set _6
term _6 :DirEq Setω
term _6 :DirEq Setω
solving _6 := Setω
compareTerm Setω =< Setω : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
inferred def  I
   :  Setω
   -->  I
coerce term      v  = I
       from type t1 = Setω
       to type   t2 = Set _7
term _7 :DirEq Setω
term _7 :DirEq Setω
solving _7 := Setω
compareTerm Setω =< Setω : Setω
Solving awake constraints. 0 remaining.
}
compareTerm I → I = I → I : Setω
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
checking declaration
{-# BUILTIN ISONE IsOne #-}
checking declaration
{-# BUILTIN ISONE IsOne #-}
checking declaration
syntax itIsOne ...
postulate itIsOne : IsOne i1
checking declaration
syntax itIsOne ...
postulate itIsOne : IsOne i1
{ checkExpr
inferred def  IsOne
   :  I → Setω
   -->  IsOne
{ checkExpr
coerce term      v  = i1
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
coerce term      v  = IsOne i1
       from type t1 = Setω
       to type   t2 = Set _8
term _8 :DirEq Setω
term _8 :DirEq Setω
solving _8 := Setω
compareTerm Setω =< Setω : Setω
Solving awake constraints. 0 remaining.
}
checked type signature itIsOne : IsOne i1 of sort  Setω
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
checking declaration
syntax IsOne1 ...
postulate IsOne1 : ∀ i j → IsOne i → IsOne (primIMax i j)
checking declaration
syntax IsOne1 ...
postulate IsOne1 : ∀ i j → IsOne i → IsOne (primIMax i j)
{ checkExpr
}
{ checkExpr
}
{ checkExpr
inferred def  IsOne
   :  (I → Setω)
   -->  IsOne
{ checkExpr
coerce term      v  = i
       from type t1 = _10
       to type   t2 = I
term _9 :DirEq Setω
term _9 :DirEq Setω
solving _9 := Setω
compareTerm _10 =< I : Setω
term _10 :DirLeq I
term _10 :DirLeq I
solving _10 := I
Solving awake constraints. 0 remaining.
}
coerce term      v  = IsOne i
       from type t1 = Setω
       to type   t2 = Set (_13 i j)
term _13 i j :DirEq Setω
term _13 i j :DirEq Setω
solving _13 := (λ i j → Setω)
compareTerm Setω =< Setω : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
inferred def  IsOne
   :  I → Setω
   -->  IsOne
{ checkExpr
inferred def  primIMax
   :  I → I → I
   -->  primIMax
{ checkExpr
coerce term      v  = i
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
coerce term      v  = j
       from type t1 = (_12 i)
       to type   t2 = I
term (_11 i) :DirEq Setω
term (_11 i) :DirEq Setω
solving _11 := λ i → Setω
compareTerm (_12 i) =< I : Setω
term (_12 i) :DirLeq I
term (_12 i) :DirLeq I
solving _12 := λ i → I
Solving awake constraints. 0 remaining.
}
coerce term      v  = primIMax i j
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
coerce term      v  = IsOne (primIMax i j)
       from type t1 = Setω
       to type   t2 = Set (_14 i j)
term _14 i j :DirEq Setω
term _14 i j :DirEq Setω
solving _14 := λ i j → Setω
compareTerm Setω =< Setω : Setω
Solving awake constraints. 0 remaining.
}
checked type signature
  IsOne1 : (i j : I) → IsOne i → IsOne (primIMax i j)
  of sort  Setω
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
checking declaration
syntax IsOne2 ...
postulate IsOne2 : ∀ i j → IsOne j → IsOne (primIMax i j)
checking declaration
syntax IsOne2 ...
postulate IsOne2 : ∀ i j → IsOne j → IsOne (primIMax i j)
{ checkExpr
}
{ checkExpr
}
{ checkExpr
inferred def  IsOne
   :  (I → Setω)
   -->  IsOne
{ checkExpr
coerce term      v  = j
       from type t1 = (_18 i)
       to type   t2 = I
term (_17 i) :DirEq Setω
term (_17 i) :DirEq Setω
solving _17 := (λ i → Setω)
compareTerm (_18 i) =< I : Setω
term (_18 i) :DirLeq I
term (_18 i) :DirLeq I
solving _18 := (λ i → I)
Solving awake constraints. 0 remaining.
}
coerce term      v  = IsOne j
       from type t1 = Setω
       to type   t2 = Set (_19 i j)
term _19 i j :DirEq Setω
term _19 i j :DirEq Setω
solving _19 := (λ i j → Setω)
compareTerm Setω =< Setω : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
inferred def  IsOne
   :  I → Setω
   -->  IsOne
{ checkExpr
inferred def  primIMax
   :  I → I → I
   -->  primIMax
{ checkExpr
coerce term      v  = i
       from type t1 = _16
       to type   t2 = I
term _15 :DirEq Setω
term _15 :DirEq Setω
solving _15 := Setω
compareTerm _16 =< I : Setω
term _16 :DirLeq I
term _16 :DirLeq I
solving _16 := I
Solving awake constraints. 0 remaining.
}
{ checkExpr
coerce term      v  = j
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
coerce term      v  = primIMax i j
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
coerce term      v  = IsOne (primIMax i j)
       from type t1 = Setω
       to type   t2 = Set (_20 i j)
term _20 i j :DirEq Setω
term _20 i j :DirEq Setω
solving _20 := λ i j → Setω
compareTerm Setω =< Setω : Setω
Solving awake constraints. 0 remaining.
}
checked type signature
  IsOne2 : (i j : I) → IsOne j → IsOne (primIMax i j)
  of sort  Setω
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
checking declaration
{-# BUILTIN ITISONE itIsOne #-}
checking declaration
{-# BUILTIN ITISONE itIsOne #-}
{ checkExpr
inferred def  itIsOne
   :  IsOne i1
   -->  itIsOne
coerce term      v  = itIsOne
       from type t1 = IsOne i1
       to type   t2 = IsOne i1
compareTerm IsOne i1 =< IsOne i1 : Setω
Solving awake constraints. 0 remaining.
}
checking declaration
{-# BUILTIN ISONE1 IsOne1 #-}
checking declaration
{-# BUILTIN ISONE1 IsOne1 #-}
{ checkExpr
inferred def  IsOne1
   :  (i j : I) → IsOne i → IsOne (primIMax i j)
   -->  IsOne1
coerce term      v  = IsOne1
       from type t1 = (i j : I) → IsOne i → IsOne (primIMax i j)
       to type   t2 = (i j : I) (i2 : IsOne i) → IsOne (primIMax i j)
compareTerm
  (i j : I) → IsOne i → IsOne (primIMax i j) =< (i j : I)
                                                (i2 : IsOne i) →
                                                IsOne (primIMax i j)
  : Setω
Solving awake constraints. 0 remaining.
}
checking declaration
{-# BUILTIN ISONE2 IsOne2 #-}
checking declaration
{-# BUILTIN ISONE2 IsOne2 #-}
{ checkExpr
inferred def  IsOne2
   :  (i j : I) → IsOne j → IsOne (primIMax i j)
   -->  IsOne2
coerce term      v  = IsOne2
       from type t1 = (i j : I) → IsOne j → IsOne (primIMax i j)
       to type   t2 = (i j : I) (j1 : IsOne j) → IsOne (primIMax i j)
compareTerm
  (i j : I) → IsOne j → IsOne (primIMax i j) =< (i j : I)
                                                (j1 : IsOne j) →
                                                IsOne (primIMax i j)
  : Setω
Solving awake constraints. 0 remaining.
}
checking declaration
{-# BUILTIN PARTIAL Partial #-}
checking declaration
{-# BUILTIN PARTIAL Partial #-}
checking declaration
{-# BUILTIN PARTIALP PartialP #-}
checking declaration
{-# BUILTIN PARTIALP PartialP #-}
checking declaration
syntax isOneEmpty ...
postulate
  isOneEmpty : ∀ {a} {A : Partial (Set a) i0} → PartialP i0 A
checking declaration
syntax isOneEmpty ...
postulate
  isOneEmpty : ∀ {a} {A : Partial (Set a) i0} → PartialP i0 A
{ checkExpr
}
{ checkExpr
inferred def  Partial
   :  {a = a₁ : .Agda.Primitive.Level} (A : Set a₁) → I → Setω
   -->  Partial
{ checkExpr
{ checkExpr
coerce term      v  = a
       from type t1 = _22
       to type   t2 = .Agda.Primitive.Level
term _21 :DirEq .Agda.Primitive.lzero
term _21 :DirEq .Agda.Primitive.lzero
solving _21 := .Agda.Primitive.lzero
compareTerm _22 =< .Agda.Primitive.Level : Set
term _22 :DirLeq .Agda.Primitive.Level
term _22 :DirLeq .Agda.Primitive.Level
solving _22 := .Agda.Primitive.Level
Solving awake constraints. 0 remaining.
}
checking Set  a against Set _a_24
term _a_24 :DirEq .Agda.Primitive.lsuc a
term _a_24 :DirEq .Agda.Primitive.lsuc a
solving _a_24 := λ {a} → .Agda.Primitive.lsuc a
compareTerm
  Set (.Agda.Primitive.lsuc a) =< Set (.Agda.Primitive.lsuc a)
  : Set (.Agda.Primitive.lsuc (.Agda.Primitive.lsuc a))
Solving awake constraints. 0 remaining.
}
{ checkExpr
coerce term      v  = i0
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
coerce term      v  = Partial (Set a) i0
       from type t1 = Setω
       to type   t2 = Set _23
term _23 :DirEq Setω
term _23 :DirEq Setω
solving _23 := λ {a} → Setω
compareTerm Setω =< Setω : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
inferred def  PartialP
   :  {a = a₁ : .Agda.Primitive.Level} (φ : I)
      (A₁ : .(o : IsOne φ) → Set a₁) →
      Setω
   -->  PartialP
{ checkExpr
coerce term      v  = i0
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
coerce term      v  = A
       from type t1 = (.(IsOne i0) → Set a)
       to type   t2 = (.(o : IsOne i0) → Set _a_26)
compareTerm
  (.(IsOne i0) → Set a) =< (.(o : IsOne i0) → Set _a_26)
  : Setω
compareTerm (IsOne i0) =< (IsOne i0) : Setω
term _a_26 :DirEq a
term _a_26 :DirEq a
solving _a_26 := λ {a} {A} → a
compareTerm (Set a) =< (Set a) : (Set (.Agda.Primitive.lsuc a))
Solving awake constraints. 0 remaining.
}
coerce term      v  = PartialP i0 A
       from type t1 = Setω
       to type   t2 = Set _25
term _25 :DirEq Setω
term _25 :DirEq Setω
solving _25 := λ {a} {A} → Setω
compareTerm Setω =< Setω : Setω
Solving awake constraints. 0 remaining.
}
checked type signature
  isOneEmpty : {a : .Agda.Primitive.Level} {A : Partial (Set a) i0} →
               PartialP i0 A
  of sort  Setω
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
checking declaration
{-# BUILTIN ISONEEMPTY isOneEmpty #-}
checking declaration
{-# BUILTIN ISONEEMPTY isOneEmpty #-}
{ checkExpr
{ checkExpr
checking that  .Agda.Primitive.Level  is not an empty type of sizes
Solving awake constraints. 0 remaining.
{ checkExpr
{ checkExpr
checking that  .(o : IsOne i0) →
               Set .l  is not an empty type of sizes
in context  {.l : .Agda.Primitive.Level}
Solving awake constraints. 0 remaining.
{ checkExpr
inferred def  isOneEmpty
   :  {a : .Agda.Primitive.Level} {A : Partial (Set a) i0} →
      PartialP i0 A
   -->  isOneEmpty
coerce term      v  = isOneEmpty
       from type t1 = .(p : IsOne i0) → _A_28 p
       to type   t2 = .(o : IsOne i0) → .A _
compareTerm
  .(p : IsOne i0) → _A_28 p =< .(o : IsOne i0) → .A _
  : Setω
compareTerm IsOne i0 =< IsOne i0 : Setω
term _a_27 :DirEq .l
term _a_27 :DirEq .l
solving _a_27 := λ {.l} {.A} → .l
compareTerm _A_28 p =< .A _ : Set .l
term _A_28 p :DirLeq .A _
term _A_28 p :DirLeq .A _
solving _A_28 := λ {.l} {.A} .z → .A _
Solving awake constraints. 0 remaining.
}
}
}
}
}
checking declaration
syntax primPFrom1 ...
primitive
  primPFrom1 :
    ∀ {a} {A : I → Set a} → A i1 → ∀ i j → Partial (A (primIMax i j)) i
checking declaration
syntax primPFrom1 ...
primitive
  primPFrom1 :
    ∀ {a} {A : I → Set a} → A i1 → ∀ i j → Partial (A (primIMax i j)) i
{ checkExpr
}
{ checkExpr
inferred def  I
   :  Setω
   -->  I
coerce term      v  = I
       from type t1 = Setω
       to type   t2 = Set _31
term _31 :DirEq Setω
term _31 :DirEq Setω
solving _31 := (λ {a} → Setω)
compareTerm Setω =< Setω : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
coerce term      v  = a
       from type t1 = _30
       to type   t2 = .Agda.Primitive.Level
term _29 :DirEq .Agda.Primitive.lzero
term _29 :DirEq .Agda.Primitive.lzero
solving _29 := .Agda.Primitive.lzero
compareTerm _30 =< .Agda.Primitive.Level : Set
term _30 :DirLeq .Agda.Primitive.Level
term _30 :DirLeq .Agda.Primitive.Level
solving _30 := .Agda.Primitive.Level
Solving awake constraints. 0 remaining.
}
{ checkExpr
{ checkExpr
coerce term      v  = i1
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
term _32 :DirEq a
term _32 :DirEq a
solving _32 := (λ {a} {A} → a)
compareTerm Set a =< Set a : Set (.Agda.Primitive.lsuc a)
Solving awake constraints. 0 remaining.
}
{ checkExpr
}
{ checkExpr
}
{ checkExpr
inferred def  Partial
   :  {a = a₁ : .Agda.Primitive.Level} (A₁ : Set a₁) → I → Setω
   -->  Partial
{ checkExpr
{ checkExpr
inferred def  primIMax
   :  I → I → I
   -->  primIMax
{ checkExpr
coerce term      v  = i
       from type t1 = _34
       to type   t2 = I
term _33 :DirEq Setω
term _33 :DirEq Setω
solving _33 := (λ {a} {A} → Setω)
compareTerm _34 =< I : Setω
term _34 :DirLeq I
term _34 :DirLeq I
solving _34 := (λ {a} {A} → I)
Solving awake constraints. 0 remaining.
}
{ checkExpr
coerce term      v  = j
       from type t1 = (_36 i)
       to type   t2 = I
term (_35 i) :DirEq Setω
term (_35 i) :DirEq Setω
solving _35 := λ {a} {A} i → Setω
compareTerm (_36 i) =< I : Setω
term (_36 i) :DirLeq I
term (_36 i) :DirLeq I
solving _36 := λ {a} {A} i → I
Solving awake constraints. 0 remaining.
}
coerce term      v  = primIMax i j
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
term _a_38 i j :DirEq a
term _a_38 i j :DirEq a
solving _a_38 := λ {a} {A} i j → a
compareTerm Set a =< Set a : Set (.Agda.Primitive.lsuc a)
Solving awake constraints. 0 remaining.
}
{ checkExpr
coerce term      v  = i
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
coerce term      v  = Partial (A (primIMax i j)) i
       from type t1 = Setω
       to type   t2 = Set (_37 i j)
term _37 i j :DirEq Setω
term _37 i j :DirEq Setω
solving _37 := λ {a} {A} i j → Setω
compareTerm Setω =< Setω : Setω
Solving awake constraints. 0 remaining.
}
compareTerm
  {a : .Agda.Primitive.Level} {A : I → Set a} →
  A i1 → (i j : I) → Partial (A (primIMax i j)) i = {a
                                                     : .Agda.Primitive.Level}
                                                    {A : I → Set a} →
                                                    A i1 →
                                                    (i j : I) .(o : IsOne i) → A (primIMax i j)
  : Setω
compareTerm .Agda.Primitive.Level = .Agda.Primitive.Level : Set
compareTerm
  {A : I → Set a} →
  A i1 → (i j : I) → Partial (A (primIMax i j)) i = {A : I → Set a} →
                                                    A i1 →
                                                    (i j : I) .(o : IsOne i) → A (primIMax i j)
  : Setω
compareTerm I → Set a = I → Set a : Setω
compareTerm I = I : Setω
compareTerm Set a = Set a : Set (.Agda.Primitive.lsuc a)
compareTerm
  A i1 → (i j : I) → Partial (A (primIMax i j)) i = A i1 →
                                                    (i j : I) .(o : IsOne i) → A (primIMax i j)
  : Setω
compareTerm A i1 = A i1 : Set a
compareTerm
  (i j : I) → Partial (A (primIMax i j)) i = (i j : I)
                                             .(o : IsOne i) →
                                             A (primIMax i j)
  : Setω
compareTerm I = I : Setω
compareTerm
  (j : I) → Partial (A (primIMax i j)) i = (j : I) .(o : IsOne i) →
                                           A (primIMax i j)
  : Setω
compareTerm I = I : Setω
compareTerm
  Partial (A (primIMax i j)) i = .(o : IsOne i) → A (primIMax i j)
  : Setω
compareTerm IsOne i = IsOne i : Setω
compareTerm A (primIMax i j) = A (primIMax i j) : Set a
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
checking declaration
syntax primPOr ...
primitive
  primPOr :
    ∀ {a} (i j : I) {A : Partial (Set a) (primIMax i j)} →
    PartialP i (λ z → A (IsOne1 i j z)) →
    PartialP j (λ z → A (IsOne2 i j z)) → PartialP (primIMax i j) A
checking declaration
syntax primPOr ...
primitive
  primPOr :
    ∀ {a} (i j : I) {A : Partial (Set a) (primIMax i j)} →
    PartialP i (λ z → A (IsOne1 i j z)) →
    PartialP j (λ z → A (IsOne2 i j z)) → PartialP (primIMax i j) A
{ checkExpr
}
{ checkExpr
inferred def  I
   :  Setω
   -->  I
coerce term      v  = I
       from type t1 = Setω
       to type   t2 = Set _41
term _41 :DirEq Setω
term _41 :DirEq Setω
solving _41 := λ {a} → Setω
compareTerm Setω =< Setω : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
inferred def  Partial
   :  {a = a₁ : .Agda.Primitive.Level} (A : Set a₁) → I → Setω
   -->  Partial
{ checkExpr
{ checkExpr
coerce term      v  = a
       from type t1 = _40
       to type   t2 = .Agda.Primitive.Level
term _39 :DirEq .Agda.Primitive.lzero
term _39 :DirEq .Agda.Primitive.lzero
solving _39 := .Agda.Primitive.lzero
compareTerm _40 =< .Agda.Primitive.Level : Set
term _40 :DirLeq .Agda.Primitive.Level
term _40 :DirLeq .Agda.Primitive.Level
solving _40 := .Agda.Primitive.Level
Solving awake constraints. 0 remaining.
}
checking Set  a against Set (_a_43 i j)
term _a_43 i j :DirEq .Agda.Primitive.lsuc a
term _a_43 i j :DirEq .Agda.Primitive.lsuc a
solving _a_43 := λ {a} i j → .Agda.Primitive.lsuc a
compareTerm
  Set (.Agda.Primitive.lsuc a) =< Set (.Agda.Primitive.lsuc a)
  : Set (.Agda.Primitive.lsuc (.Agda.Primitive.lsuc a))
Solving awake constraints. 0 remaining.
}
{ checkExpr
inferred def  primIMax
   :  I → I → I
   -->  primIMax
{ checkExpr
coerce term      v  = i
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
coerce term      v  = j
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
coerce term      v  = primIMax i j
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
coerce term      v  = Partial (Set a) (primIMax i j)
       from type t1 = Setω
       to type   t2 = Set (_42 i j)
term _42 i j :DirEq Setω
term _42 i j :DirEq Setω
solving _42 := λ {a} i j → Setω
compareTerm Setω =< Setω : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
inferred def  PartialP
   :  ({a = a₁ : .Agda.Primitive.Level} (φ : I)
       (A₁ : .(o : IsOne φ) → Set a₁) →
       Setω)
   -->  PartialP
{ checkExpr
coerce term      v  = i
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
checking that  IsOne i  is not an empty type of sizes
in context  {a : .Agda.Primitive.Level} (i : I) (j : I)
            {A : Partial (Set a) (primIMax i j)}
Solving awake constraints. 0 remaining.
{ checkExpr
{ checkExpr
inferred def  IsOne1
   :  (i₁ j₁ : I) → IsOne i₁ → IsOne (primIMax i₁ j₁)
   -->  IsOne1
{ checkExpr
coerce term      v  = i
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
coerce term      v  = j
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
coerce term      v  = z
       from type t1 = (IsOne i)
       to type   t2 = (IsOne i)
compareTerm (IsOne i) =< (IsOne i) : Setω
Solving awake constraints. 0 remaining.
}
coerce term      v  = IsOne1 i j z
       from type t1 = IsOne (primIMax i j)
       to type   t2 = IsOne (primIMax i j)
compareTerm IsOne (primIMax i j) =< IsOne (primIMax i j) : Setω
Solving awake constraints. 0 remaining.
}
term _a_45 i j :DirEq a
term _a_45 i j :DirEq a
solving _a_45 := λ {a} i j {A} → a
compareTerm Set a =< Set a : Set (.Agda.Primitive.lsuc a)
Solving awake constraints. 0 remaining.
}
}
coerce term      v  = PartialP i (λ .z → A _)
       from type t1 = Setω
       to type   t2 = Set (_44 i j)
term _44 i j :DirEq Setω
term _44 i j :DirEq Setω
solving _44 := (λ {a} i j {A} → Setω)
compareTerm Setω =< Setω : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
inferred def  PartialP
   :  ({a = a₁ : .Agda.Primitive.Level} (φ : I)
       (A₁ : .(o : IsOne φ) → Set a₁) →
       Setω)
   -->  PartialP
{ checkExpr
coerce term      v  = j
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
checking that  IsOne j  is not an empty type of sizes
in context  {a : .Agda.Primitive.Level} (i : I) (j : I)
            {A : Partial (Set a) (primIMax i j)}
Solving awake constraints. 0 remaining.
{ checkExpr
{ checkExpr
inferred def  IsOne2
   :  (i₁ j₁ : I) → IsOne j₁ → IsOne (primIMax i₁ j₁)
   -->  IsOne2
{ checkExpr
coerce term      v  = i
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
coerce term      v  = j
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
coerce term      v  = z
       from type t1 = (IsOne j)
       to type   t2 = (IsOne j)
compareTerm (IsOne j) =< (IsOne j) : Setω
Solving awake constraints. 0 remaining.
}
coerce term      v  = IsOne2 i j z
       from type t1 = IsOne (primIMax i j)
       to type   t2 = IsOne (primIMax i j)
compareTerm IsOne (primIMax i j) =< IsOne (primIMax i j) : Setω
Solving awake constraints. 0 remaining.
}
term _a_47 i j :DirEq a
term _a_47 i j :DirEq a
solving _a_47 := λ {a} i j {A} → a
compareTerm Set a =< Set a : Set (.Agda.Primitive.lsuc a)
Solving awake constraints. 0 remaining.
}
}
coerce term      v  = PartialP j (λ .z → A _)
       from type t1 = Setω
       to type   t2 = Set (_46 i j)
term _46 i j :DirEq Setω
term _46 i j :DirEq Setω
solving _46 := (λ {a} i j {A} → Setω)
compareTerm Setω =< Setω : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
inferred def  PartialP
   :  {a = a₁ : .Agda.Primitive.Level} (φ : I)
      (A₁ : .(o : IsOne φ) → Set a₁) →
      Setω
   -->  PartialP
{ checkExpr
inferred def  primIMax
   :  I → I → I
   -->  primIMax
{ checkExpr
coerce term      v  = i
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
coerce term      v  = j
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
coerce term      v  = primIMax i j
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
coerce term      v  = A
       from type t1 = (.(IsOne (primIMax i j)) → Set a)
       to type   t2 = (.(o : IsOne (primIMax i j)) → Set (_a_49 i j))
compareTerm
  (.(IsOne (primIMax i j)) → Set a) =< (.(o : IsOne (primIMax i j)) →
                                        Set (_a_49 i j))
  : Setω
compareTerm (IsOne (primIMax i j)) =< (IsOne (primIMax i j)) : Setω
term (_a_49 i j) :DirEq a
term (_a_49 i j) :DirEq a
solving _a_49 := λ {a} i j {A} → a
compareTerm (Set a) =< (Set a) : (Set (.Agda.Primitive.lsuc a))
Solving awake constraints. 0 remaining.
}
coerce term      v  = PartialP (primIMax i j) A
       from type t1 = Setω
       to type   t2 = Set (_48 i j)
term _48 i j :DirEq Setω
term _48 i j :DirEq Setω
solving _48 := λ {a} i j {A} → Setω
compareTerm Setω =< Setω : Setω
Solving awake constraints. 0 remaining.
}
compareTerm
  {a : .Agda.Primitive.Level} (i j : I)
  {A : Partial (Set a) (primIMax i j)} →
  PartialP i (λ .z → A _) →
  PartialP j (λ .z → A _) → PartialP (primIMax i j) A = {a
                                                         : .Agda.Primitive.Level}
                                                        (i j : I)
                                                        {A : .(o : IsOne (primIMax i j)) → Set a} →
                                                        (.(i2 : IsOne i) → A _) →
                                                        (.(j1 : IsOne j) → A _) →
                                                        .(o : IsOne (primIMax i j)) → A _
  : Setω
compareTerm .Agda.Primitive.Level = .Agda.Primitive.Level : Set
compareTerm
  (i j : I) {A : Partial (Set a) (primIMax i j)} →
  PartialP i (λ .z → A _) →
  PartialP j (λ .z → A _) → PartialP (primIMax i j) A = (i j : I)
                                                        {A : .(o : IsOne (primIMax i j)) → Set a} →
                                                        (.(i2 : IsOne i) → A _) →
                                                        (.(j1 : IsOne j) → A _) →
                                                        .(o : IsOne (primIMax i j)) → A _
  : Setω
compareTerm I = I : Setω
compareTerm
  (j : I) {A : Partial (Set a) (primIMax i j)} →
  PartialP i (λ .z → A _) →
  PartialP j (λ .z → A _) → PartialP (primIMax i j) A = (j : I)
                                                        {A : .(o : IsOne (primIMax i j)) → Set a} →
                                                        (.(i2 : IsOne i) → A _) →
                                                        (.(j1 : IsOne j) → A _) →
                                                        .(o : IsOne (primIMax i j)) → A _
  : Setω
compareTerm I = I : Setω
compareTerm
  {A : Partial (Set a) (primIMax i j)} →
  PartialP i (λ .z → A _) →
  PartialP j (λ .z → A _) → PartialP (primIMax i j) A = {A
                                                         : .(o : IsOne (primIMax i j)) → Set a} →
                                                        (.(i2 : IsOne i) → A _) →
                                                        (.(j1 : IsOne j) → A _) →
                                                        .(o : IsOne (primIMax i j)) → A _
  : Setω
compareTerm
  .(o : IsOne (primIMax i j)) → Set a = Partial (Set a)
                                        (primIMax i j)
  : Setω
compareTerm IsOne (primIMax i j) = IsOne (primIMax i j) : Setω
compareTerm Set a = Set a : Set (.Agda.Primitive.lsuc a)
compareTerm
  PartialP i (λ .z → A _) →
  PartialP j (λ .z → A _) → PartialP (primIMax i j) A = (.(i2
                                                           : IsOne i) →
                                                         A _) →
                                                        (.(j1 : IsOne j) → A _) →
                                                        .(o : IsOne (primIMax i j)) → A _
  : Setω
compareTerm .(i2 : IsOne i) → A _ = PartialP i (λ .z → A _) : Setω
compareTerm IsOne i = IsOne i : Setω
compareTerm A _ = A _ : Set a
compareTerm
  PartialP j (λ .z → A _) → PartialP (primIMax i j) A = (.(j1
                                                           : IsOne j) →
                                                         A _) →
                                                        .(o : IsOne (primIMax i j)) → A _
  : Setω
compareTerm .(j1 : IsOne j) → A _ = PartialP j (λ .z → A _) : Setω
compareTerm IsOne j = IsOne j : Setω
compareTerm A _ = A _ : Set a
compareTerm
  PartialP (primIMax i j) A = .(o : IsOne (primIMax i j)) → A _
  : Setω
compareTerm IsOne (primIMax i j) = IsOne (primIMax i j) : Setω
compareTerm A p = A _ : Set a
  a    = .(o : IsOne (primIMax i j)) → Set a
  v    = A
  arg1 = p
  arg2 = _
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
checking declaration
syntax primComp ...
primitive
  primComp :
    ∀ {a} (A : (i : I) → Set (a i)) (φ : I) →
    (∀ i → Partial (A i) φ) → (a₁ : A i0) → A i1
checking declaration
syntax primComp ...
primitive
  primComp :
    ∀ {a} (A : (i : I) → Set (a i)) (φ : I) →
    (∀ i → Partial (A i) φ) → (a₁ : A i0) → A i1
{ checkExpr
}
{ checkExpr
inferred def  I
   :  Setω
   -->  I
coerce term      v  = I
       from type t1 = Setω
       to type   t2 = Set _52
term _52 :DirEq Setω
term _52 :DirEq Setω
solving _52 := λ {a} → Setω
compareTerm Setω =< Setω : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
}
{ checkExpr
inferred def  I
   :  Setω
   -->  I
coerce term      v  = I
       from type t1 = Setω
       to type   t2 = Set (_55 A)
term _55 A :DirEq Setω
term _55 A :DirEq Setω
solving _55 := λ {a} A → Setω
compareTerm Setω =< Setω : Setω
Solving awake constraints. 1 remaining.
Solving awake constraints. 0 remaining.
}
{ checkExpr
}
{ checkExpr
inferred def  Partial
   :  {a = a₁ : .Agda.Primitive.Level} (A₁ : Set a₁) → I → Setω
   -->  Partial
{ checkExpr
{ checkExpr
coerce term      v  = i
       from type t1 = (_57 A φ)
       to type   t2 = I
term (_56 A φ) :DirEq Setω
term (_56 A φ) :DirEq Setω
solving _56 := λ {a} A φ → Setω
compareTerm (_57 A φ) =< I : Setω
term (_57 A φ) :DirLeq I
term (_57 A φ) :DirLeq I
solving _57 := λ {a} A φ → I
Solving awake constraints. 1 remaining.
Solving awake constraints. 0 remaining.
}
term _a_59 A φ i :DirEq _54 i
term _a_59 A φ i :DirEq _54 i
solving _a_59 := λ {a} A φ i → _54 i
compareTerm
  Set (_54 i) =< Set (_54 i)
  : Set (.Agda.Primitive.lsuc (_54 i))
Solving awake constraints. 1 remaining.
Solving awake constraints. 0 remaining.
}
{ checkExpr
coerce term      v  = φ
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
coerce term      v  = Partial (A i) φ
       from type t1 = Setω
       to type   t2 = Set (_58 A φ i)
term _58 A φ i :DirEq Setω
term _58 A φ i :DirEq Setω
solving _58 := λ {a} A φ i → Setω
compareTerm Setω =< Setω : Setω
Solving awake constraints. 1 remaining.
Solving awake constraints. 0 remaining.
}
{ checkExpr
{ checkExpr
coerce term      v  = i0
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
term _60 A φ :DirEq _54 i0
term _60 A φ :DirEq _54 i0
solving _60 := λ {a} A φ → _54 i0
compareTerm
  Set (_54 i0) =< Set (_54 i0)
  : Set (.Agda.Primitive.lsuc (_54 i0))
Solving awake constraints. 1 remaining.
Solving awake constraints. 0 remaining.
}
{ checkExpr
{ checkExpr
coerce term      v  = i1
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
term _61 A φ a :DirEq _54 i1
term _61 A φ a :DirEq _54 i1
solving _61 := λ {a} A φ a₁ → _54 i1
compareTerm
  Set (_54 i1) =< Set (_54 i1)
  : Set (.Agda.Primitive.lsuc (_54 i1))
Solving awake constraints. 1 remaining.
Solving awake constraints. 0 remaining.
}
compareTerm
  {a : _51} (A : (i : I) → Set (_54 i)) (φ : I) →
  ((i : I) → Partial (A i) φ) → A i0 → A i1 = {a
                                               : I → .Agda.Primitive.Level}
                                              (A : (i : I) → Set (a i)) (φ : I) →
                                              ((i : I) .(o : IsOne φ) → A i) → A i0 → A i1
  : Setω
term _50 :DirEq Setω
term _50 :DirEq Setω
solving _50 := Setω
compareTerm I → .Agda.Primitive.Level = _51 : Setω
term _51 :DirEq I → .Agda.Primitive.Level
term _51 :DirEq I → .Agda.Primitive.Level
solving _51 := I → .Agda.Primitive.Level
compareTerm
  (A : (i : I) → Set (_54 i)) (φ : I) →
  ((i : I) → Partial (A i) φ) → A i0 → A i1 = (A
                                               : (i : I) → Set (a i))
                                              (φ : I) →
                                              ((i : I) .(o : IsOne φ) → A i) → A i0 → A i1
  : Setω
compareTerm (i : I) → Set (a i) = (i : I) → Set (_54 i) : Setω
compareTerm I = I : Setω
term _54 i :DirEq a i
term _54 i :DirEq a i
solving _54 := λ {a} i → a i
compareTerm
  Set (a i) = Set (a i)
  : Set (.Agda.Primitive.lsuc (a i))
compareTerm
  (φ : I) → ((i : I) → Partial (A i) φ) → A i0 → A i1 = (φ : I) →
                                                        ((i : I) .(o : IsOne φ) → A i) → A i0 → A i1
  : Setω
compareTerm I = I : Setω
compareTerm
  ((i : I) → Partial (A i) φ) → A i0 → A i1 = ((i : I)
                                               .(o : IsOne φ) →
                                               A i) →
                                              A i0 → A i1
  : Setω
compareTerm
  (i : I) .(o : IsOne φ) → A i = (i : I) → Partial (A i) φ
  : Setω
compareTerm I = I : Setω
compareTerm .(o : IsOne φ) → A i = Partial (A i) φ : Setω
compareTerm IsOne φ = IsOne φ : Setω
compareTerm A i = A i : Set (a i)
compareTerm
  A i0 → A i1 = A i0 → A i1
  : Set (a i0 .Agda.Primitive.⊔ a i1)
Solving awake constraints. 1 remaining.
{ checkExpr
coerce term      v  = i
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
coerce term      v  = a i
       from type t1 = .Agda.Primitive.Level
       to type   t2 = .Agda.Primitive.Level
compareTerm .Agda.Primitive.Level =< .Agda.Primitive.Level : Set
Solving awake constraints. 0 remaining.
Solving awake constraints. 1 remaining.
compareTerm a i = a i : .Agda.Primitive.Level
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
Removed 0 unused definitions.
checking declaration
module Issue2754 where
checking section Issue2754
adding section: Issue2754 0
    actual tele:
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
Removed 0 unused definitions.
